/* Autogenerated: ./src/ExtractionOCaml/word_by_word_montgomery pasta_fp 64 '2^254 + 45560315531419706090280762371685220353' */
/* curve description: pasta_fp */
/* machine_wordsize = 64 (from "64") */
/* requested operations: (all) */
/* m = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001 (from "2^254 + 45560315531419706090280762371685220353") */
/*                                                                    */
/* NOTE: In addition to the bounds specified above each function, all */
/*   functions synthesized for this Montgomery arithmetic require the */
/*   input to be strictly less than the prime modulus (m), and also   */
/*   require the input to be in the unique saturated representation.  */
/*   All functions also ensure that these two properties are true of  */
/*   return values.                                                   */
/*  */
/* Computed values: */
/* eval z = z[0] + (z[1] << 64) + (z[2] << 128) + (z[3] << 192) */
/* bytes_eval z = z[0] + (z[1] << 8) + (z[2] << 16) + (z[3] << 24) + (z[4] << 32) + (z[5] << 40) + (z[6] << 48) + (z[7] << 56) + (z[8] << 64) + (z[9] << 72) + (z[10] << 80) + (z[11] << 88) + (z[12] << 96) + (z[13] << 104) + (z[14] << 112) + (z[15] << 120) + (z[16] << 128) + (z[17] << 136) + (z[18] << 144) + (z[19] << 152) + (z[20] << 160) + (z[21] << 168) + (z[22] << 176) + (z[23] << 184) + (z[24] << 192) + (z[25] << 200) + (z[26] << 208) + (z[27] << 216) + (z[28] << 224) + (z[29] << 232) + (z[30] << 240) + (z[31] << 248) */
#include <stdint.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stddef.h>
#include <string.h>

#if (-1 & 3) != 3
#error "This code only works on a two's complement system"
#endif

#include "pasta.h"

void fiat_pasta_fp_pow(uint64_t out1[4], const uint64_t arg1[4], const bool* msb_bits, const size_t bits_len) {
  uint64_t tmp[4];
  memcpy(out1, mina_fp_one, 32);

  // square and multiply
  for (size_t i = 0; i < bits_len; ++i) {
    // out1 = out1 * out1
    memcpy(tmp, out1, 32);
    fiat_pasta_mul(out1, tmp, tmp, false);

    if (msb_bits[i]) {
      // out1 = out1 * arg1
      memcpy(tmp, out1, 32);
      fiat_pasta_mul(out1, tmp, arg1, false);
    }
  }
}

void fiat_pasta_fp_inv(uint64_t out1[4], const uint64_t arg1[4]) {
  // invert by Fermat's little theorem:
  // x^{p - 2} * x = 1

  const bool P_MINUS_2[] = {
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1,
    0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
  };
  fiat_pasta_fp_pow(out1, arg1, P_MINUS_2, 255);
}

bool fiat_pasta_fp_equals_one(const uint64_t x[4]) {
  uint64_t x_minus_1[4];
  fiat_pasta_sub(x_minus_1, x, mina_fp_one, false);

  uint64_t x_minus_1_nonzero;
  fiat_pasta_nonzero(&x_minus_1_nonzero, x_minus_1);
  if (x_minus_1_nonzero) {
    return false;
  } else {
    return true;
  }
}

int fiat_pasta_fp_legendre(const uint64_t arg1[4]) {
  uint64_t tmp[4];
  uint64_t input_non_zero;

  fiat_pasta_fp_pow(tmp, arg1, P_MINUS_1_OVER_2, 254);
  fiat_pasta_nonzero(&input_non_zero, arg1);
  if (input_non_zero) {
    if (fiat_pasta_fp_equals_one(tmp)) {
      return 1;
    } else {
      return -1;
    }
  } else {
    return 0;
  }
}

bool fiat_pasta_fp_sqrt(uint64_t x[4], const uint64_t value[4]) {
    // A few assertions to make sure s, t, and nqr are initialized.
    if (fiat_pasta_equals_zero(value)) {
      for (size_t j = 0; j < 4; ++j) { x[j] = 0; }
      return true;
    }

    uint64_t check[4];
    fiat_pasta_fp_pow(check, value, P_MINUS_1_OVER_2, P_MINUS_1_OVER_2_LEN);
    if (!fiat_pasta_fp_equals_one(check)) {
      return false;
    }

    size_t v = 32;

    // z = 5^( (p - 1)/2^32 )
    uint64_t z[4] = { 0xa28db849bad6dbf0, 0x9083cd03d3b539df, 0xfba6b9ca9dc8448e, 0x3ec928747b89c6da };

    const bool T_MINUS_ONE_DIV_TWO[] = {
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0,
      0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1,
      0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0
    };
    const size_t T_MINUS_ONE_DIV_TWO_LEN = 222;

    // w = value^((t - 1) / 2)
    // where
    // t = (p - 1) / 2^32
    uint64_t w[4];
    fiat_pasta_fp_pow(w, value, T_MINUS_ONE_DIV_TWO, T_MINUS_ONE_DIV_TWO_LEN);

    fiat_pasta_mul(x, value, w, false);

    uint64_t b[4];
    fiat_pasta_mul(b, x, w, false);

    // compute square root with Tonelli--Shanks
    // (does not terminate if not a square!)

    uint64_t b2m[4];
    uint64_t tmp[4];

    while (! fiat_pasta_fp_equals_one(b))
    {
        size_t m = 0;
        memcpy(b2m, b, 32);

        while (! fiat_pasta_fp_equals_one(b2m))
        {
          // looping here
          // b2m = b2m * b2m
            memcpy(tmp, b2m, 32);
            fiat_pasta_mul(b2m, tmp, tmp, false);

            /* invariant: b2m = b^(2^m) after entering this loop */
            m += 1;
        }

        int j = v-m-1;
        memcpy(w, z, 32);

        while (j > 0)
        {
            memcpy(tmp, w, 32);
            fiat_pasta_mul(w, tmp, tmp, false);
            --j;
        } // w = z^2^(v-m-1)

        fiat_pasta_mul(z, w, w, false);

        memcpy(tmp, b, 32);
        fiat_pasta_mul(b, tmp, z, false);

        memcpy(tmp, x, 32);
        fiat_pasta_mul(x, tmp, w, false);

        v = m;
    }

    return true;
}
